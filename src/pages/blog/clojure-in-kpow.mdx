---
author: 'jon'
title: 'Clojure in Kafka: Kpow'
description: 'Building a Kafka toolkit'
category: 'leadership'
layout: '../../layouts/BlogPost.astro'
publishedDate: '16 Feb 2023'
heroImage: 'embracing-imperfection.jpg'
clojureIn: { season: 'two' }
---

import { Image } from '@astrojs/image/components'

## Kpow

**Jon: Could you tell us who you are and what Kpow is?**

**Derek:** So I'm Derek and I'm the CEO and one of the Co-Founders of Factor House. We’re an independent software house based in Melbourne, Australia.

Kpow is a toolkit for engineers using Apache Kafka. It provides a way for engineers to control, monitor, to search for data in Kafka. Searching is the number one use-case.

We have a range of users, from teams starting with Kafka and looking for a control-console to make sense of things, and then we've got experienced teams developing complex platforms in the streaming compute space. They use the full range of what Kpow offers including live monitoring of Kafka streams applications, topology and metrics visualizations. We also have platform teams, running fleets of Kafka clusters who want to access and change configuration.

We provide an enterprise grade web application, with security integrations such as SAML, LDAP, OAuth and KeyCloak. It's not a Sass application, rather something that you install on your network in close proximity to your Kafka cluster with zero dependencies. It's a single docker container and uses Kafka as a data store. Since we're not a SaaS product we don't have any access to user data whatsoever.

Basically Kpow is like a toolbox. Apache Kafka is phenomenal, probably the number one project in the Apache Software Foundation by contributions and activity.

**Jon: How many users?**

**Derek:** We've got 10,000 active users spread over 100 countries. We're deployed in every way you can imagine, in every cloud, inside of Kubernetes, Fargate, and in ECS. We're running in a box inside of a cupboard somewhere, where they're not using Docker but using the Java 8 jar.

## The team

**Jon: Could you give us a bit of an overview of your developer team?**

**Derek:** So the actual hands-on developers are myself and Tom, the whole company is four people, Tom and I built the entire system ourselves.

I'm the ‘Thorny Old JVM nerd’ and Tom is 10 years younger, where his natural habitat is the browser, and so we compliment each other. Tom leads the front end and he knows where to go. He pushed us into Shadow CLJS and he's extremely talented.

We prefer to work in small teams, where our philosophy is active, ubiquitous conversation about the things that we're building, and ownership.

I'm a firm believer that that good software comes from small teams who are empowered. I am a big fan of Dijkstra and the faxes and memos he used to post. One was ("why is software so expensive?")[https://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD648.html] and it has two or three of my favorite stories in it.

One time he's there solving a problem to do with memory pages and he's just in a room talking to his colleague. Over a period of months they slowly form this ubiquitous language, by talking and mulling over ideas.

Dijkstra says that if someone walked into the room, after six months and ask what have you been doing? It wouldn’t look like they’d done anything! But they have been solving the problem and building up a language.

At the point where Kpow now is at, four years in, we've become experts in this problem space. I knew the least about it when we started and back then we were most capable of making the greatest mistakes.

And it's not that we just sat around talking for six months, we started shipping very, quickly. Clojure gives us that fluidity to not make dreadful mistakes earlier that become cemented in.

## Background

**Jon: How did you get into Clojure, what's your background?**

**Derek:** I've been programming since I was six, starting on Spectrum 48K.

I first bulletin boards in New Zealand and then I came out of University about 2000, initially learning Turbo Pascal, but switched to Java, following the one true path of Object Oriented design.

I had this professor, he was a Canadian Olympic speed skater, and he was like, ‘look, we're doing all of this but I've just gotta tell you, when you go out there and get a job, the only thing you're gonna do is work with lists of data and maps of data and you're going to be moving it around from one place to another and everything else is just rubbish’. And he was absolutely correct.

I've operated in the JVM space forever, which helps me with Clojure.

**Jon: And Clojure?:**

**Derek:** We had a mutual colleague, who after he chatted to you, chatted to me, about Clojure. I was like ‘I’m not sure that’s a great idea’. I didn’t know anything about it and I was comfortable, being in the Enterprise space in London where everything was Java and every job was Java.

My wife and I moved to Melbourne which is a small market and I decided to work with Clojure and distributed systems, building a suite of systems processing email for a company, over the course of three to four years. I built about 13/14 systems, all in Clojure from scratch, also using Casandra, Storm, and Kafka.

We went through several iterations of writing really bad Clojure, giving me time to learn, and to relearn what I'd done previously in my career.

**Jon: How did KPow start?:**

Kylie and I decided in 2019 to stop working on consulting and to build the product, we could see from our clients and customers that they wanted.

## Harder stuff:

**Jon: What are you working on now?**

**Derek:** We're shipping dark mode for our web applicaiton in the next couple of days. We might then integrate with Flink.

But now we have more than enough feedback and direction from the market, engineers who are really passionate about our product, who work with it daily.

There’s no need to introduce concretions later on. We're only communicating within our team, right? We don't have to set out in code. Formalisations that would allow you or other computer programmers to understand the internals of what we do. I think Rich (Hickey) really got it right when he speaks about the difference between information systems and abstract systems, that was something I didn't understand at all as a young developer. And l I actually, funnily enough, I tried talking about it at the Conj, but I was talking about products versus frameworks, which is the same idea but much less elegantly put. And you know, it's true that the only thing I've ever built is information systems. But the tools that we're taught to think about and execute programming as developers, particularly at that time in the Java way of doing things, are the tools for building abstract systems, they're, you know, jetty is a great example of this. Abstract system that solves a problem supposedly of HTTP servers which has RFC's, it has agreements and it's got like it's extremely formal and correctly so. And so the systems that we work in. Building, they immediately have these abstract systems within them. Kafka is another one. And so as a young developer, I think you can look at these things and think, well, that's how I've got to build my trading platform. It's got to have concretions all the way through it because that's alI I see everywhere. And that's also naively what you're told to do. And I think Clojure is the most powerful way I have of building information systems that are commercially viable because they're on the JVM. They can be packaged up as a jar. They’re a known quantifiable thing that can run somewhere and we get to leverage all of the abstract systems and not mimic them. We've retained this flexibility all the way through our delivery which is easier to do because we’re a really small team who've been working together for three years now.

In terms of code base we’re nearing 10,000 commits. Kpow is all written in Clojure, both front and back end. We have a series of systems that run in AWS Lambda that do license provisioning which is all written in Clojure too.

**Jon: Are there any sort of tools and libraries that you would give a shout out to?**

**Derek:** Mostly around code cleanliness and the nuts and bolts of project stuff; so Shadow CLJS is something that we adopted, we still use Lanigan.We moved to Shadow which allows us to use NPM directly. This allows us to move quickly through the front end and freshen up a lot of stuff and has had a large impact on the quality of the front end of our products.

And then there's a bunch of stuff that we use like Condo, we did rely on Integrant for a long  time. We've actually replaced it with our own framework that allows us to do mutable stuff, which is quite interesting, we might open source it in the future.

We've just opened sourced something called Slipway which is a wrap-around Jetty that allows you to use Jetty 9,10 and 11. I think it's one of the things with Clojure it attracts a lot of enthusiasts as well as people who are trying to build real-world systems, and sometimes it can be hard to determine which libraries are a flight of fancy and which have real concrete value.

But to be honest, we've never really had a need for much outside core Clojure core data structures. And the webbing that allows us to build the project and work in the front end as well, such as Clojure script.  Reframes is probably the biggest state management one that we use in the front end and are quite reliant on and Instapass is one of the best things I've ever worked with. It's fundamental to our product because we've implemented JQ In Clojure and you can use it inside Kpow to filter data coming off kafka topics so we've implemented one language in another language and Instapass allows you to do that which is phenomenal.

**Jon: It sounds like you've deliberately kept the footprint small?**

**Derek:** I used to be a contributor to Netty back in the day and we had a 0 dependencies mantra, which is really hard with less experienced developers. We have no dependencies that add any ideas to the functional way of doing things in Clojure. We don’t use Fungal Cats or anything like that. Kpow is simply Java based libraries with Interop because it's too hard to stay relevant. You're relying on someone to maintain their library, which moves along at their own pace creating dependencies. Java Interop is idiomatic Clojure. It's absolutely fine. But then that's my familiarity with the JVM.

**Jon: it's more beautiful to write Java in Clojure than Java in Java.**

**Derek:** Absolutely agree. We really value those things like Condo. A large part of it is reducing those dependencies because we run NVD scans on everything and if our build breaks if we've got any CVE's that are unmanaged we manage to that degree. When you push a commit, it checks out all of your dependencies from the pom and it scans for CVE's so that you can track them. We get audited and PEN tested regularly this allows us to publish a security report stating we have no known CVE’s at this point in time.

**Jon: What's your view on the state of things currently with Clojure?**

**Derek:** It's really interesting to me that there always seems to be this expectation within the Clojure Developer Community that more things are going to be given to them constantly.
I think there’s a lot of pressure on the team at Cognitec, they do a great job of stewarding which is beyond the capabilities of most people.

We don’t have a lot of gaps at the moment in terms of what we need. What I would like to understand is more the road map for how Clojure anticipates keeping up with the changes in JVM.

But in terms of the state of Clojure I believe it gives us the tooling we need to deliver think

**Jon: Is there anything that you feel we haven’t covered, anything you’d like to add?**

**Derek:** No, I think we’ve covered everything, thanks for taking the time to listen and I really appreciate what you’re doing with pushing Clojure onwards and upwards.
