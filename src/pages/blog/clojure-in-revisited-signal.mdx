---
author: 'jon'
title: 'Clojure in Revisited: Signal
description: ''
category: 'clojure-in'
layout: '../../layouts/BlogPostClojureIn.astro'
publishedDate: '2023-06-20'
heroImage: 'gresham-logo-clojurein-new.jpg'
clojureIn:
  {
    season: 'two',
    industry: 'finance',
    quote: '"Our heart is in Clojure."'
  }
---

import { Image } from '@astrojs/image/components'

Signal is an AI company that extracts knowledge from unstructured textual content and processes near to 5 million documents a day from various data sources, providing insights to it's subscribers.

JUXT visited Signal for a Clojure In [five years ago](https://www.juxt.pro/blog/clojure-in-signal/). I wanted to revisit to understand if Clojure has stood the test of time, and how they feel about it now.

I met with VP of engineering Alan Wright, Senior Software Engineers Joachim Draeger and Charlie Briggs, Richard Lewis Jones on the Search Team, Rahul DÃ© (Site Reliability Engineer), and CTO Luca Grulla.

## Languages

**Jon: What languages do you use now?**

**Luca:** Historically, we've built everything using three ecosystems, JVM with Clojure, Node with JavaScript, and Python.

We use JavaScript for the front-end and some APIs, and Python for machine learning and data science.

**Joachim:** Yeah, Clojure is then our go-to language for APIs and data manipulation. It also shines if you need to do anything fast in a multi-threaded way.

**Richard:** We're also using Clojure to build an abstract interface on top of Elastic Search.

**Jon: Have you looked at Clojure for the Data Science part, rather than Python?**

**Charlie:** - We've realized that if you need to do any data science, just start with Python. We haven't tried to shoehorn Clojure into that ecosystem. In the previous Clojure In interview, Miguel talked about the improvements of data science on Clojure and it doesn't seem to have come to fruition in any way that that's usable for us in production.

**Joachim:** You can't really compare the data science ecosystem between Clojure and Python, it's all happening in the Python space.

**Jon: So why not use Python throughout?**

**Charlie:** The most powerful feature I find with Clojure is how easy it is to do multi-threading and parallelism and get good performance out of the box. It's very hard to use Python because of global interpreter lock and similar issues. Whenever we've tried to tackle it, it's always been a bit of a pain.

**Joachim:** It takes a lot more effort with Python to get all the dependencies straight and to get it to work properly in Docker. The JVM is a lot more mature in that sense. It's easier to run Clojure services in production, to scale and to monitor them than it is for for Python.

Clojure is also great for any kind of data manipulation. Our machine learning pipelines and APIs are all using a mix of Python/Clojure.

**Rahul:** We've historically used Python for infrastructure automation. Where we're dealing with a lot of unstructured data and especially query analysis for Elastic, we will use a mix of languages including Clojure. If you compare Golang and Clojure in terms of handling unstructured dynamic data, that's a big plus point for Clojure.

**Jon: Could you expand more on what you do with unstructured dynamic data?**

**Rahul:** The primary use case that we have is to run this massive search cluster and we monitor this cluster at all times. We need to protect it against large queries that could overwhelm or load the cluster. Clojure allows us to walk the tree with it's standard library and preemptively measure the severity of a query and therefore reduce the impact.

## Clojure

**Jon:** It's quite inspiring, you've got those three different languages for each relevant area and you choose which one works best. It's great to hear that Clojure is holding it's own.

**Charlie:** It's nice to see that if you go back to a project that was written five years ago and it's basically more or less still doing the same thing and holds up well. It seems there's definitely less fatigue in terms of progression in the style than we've seen in Python or JavaScript.

**Luca:** This to me is the strength of Clojure. The design of the core library is of such high quality that there's no major changes, not because there's no innovation but because it achieves such a level of instruction. Unlike other languages where the framework is constantly being revisited, you can do a lot with the core library, it stands the testament of time.

**Jon:** How have you found it in terms of hiring and training for Clojure?

**Charlie:** I joined because I wanted to learn Clojure.

**Richard:** I don't consider there a problem picking up Clojure. It's an attractive thing for people who have discovered it.

For example we've had two recent joiners who hadn't used Clojure before. One has Lisp/C# experience and the other had Python. They were both aware of functional language concepts and they were quick to pick it up.

To help with this, for a time we ran a Clojure club, so people who aren't familiar can get support from people with experience.

**Rahul:** The club was born from people who were learning it and they've built a framework and wiki which is available to the team, which shows them how to go about the learning.

**Charlie:** I think it's great we have this now as when I joined it wasn't so in-depth, there were reading suggestions but now it's more comprehensive.

**Jon: It's great, you've got a full range of people: from juniors learning the technology, people joining for the technology, and then people you've pulled across from adjacent technologies like Python and Common Lisp. Have you had any challenges from the team with your decision to adopt Clojure?**

**Richard:** Not really, it's nice to play around with new technologies but our heart is in Clojure.

## Working with dynamic data

**Jon: It feels you're aligned to dynamic languages. Do you feel the static versus dynamic debate has moved on at all?**

**Richard:** I'm attracted to the elegance of some of the newer languages out there on the frontend such as Elm and Reason. I'm not a fan of TypeScripts because it's a halfway house, it's not inferred, so you just end up with horrible types you've got to deal with. Languages that are properly typed first, they're nice, but it's not necessarily suitable for a lot of what we're doing, so Clojure wins.

**Charlie:** We've had some pain with things not being typed for maintenance, such as APIs. I feel the solution for that is not necessarily adding types to the language but definitely adding more schemas, and structure to the data you consume and produce.

We tried to use Clojure spec to make our boundaries more strict. We found found it hard to work with, and now we use Mali and it just seems more intuitive. We never really got to grips with how to structure our specs and actually to use them in the right context, like development Vs production. You seem to need to do a lot of work to make actually fit for human consumption.

**Richard:** On my team we also use Mali and other tools from Metosin for routing.

## Tooling

**Jon: What tools and libraries do you use?**

Richard - In the Search team we've gone a bit around the houses really with the ideal set up in terms of tooling but we're aiming for simplicity at all costs. For lifecycle we're with Mount and configuration we're using CPROP and I think that's a fairly simple and easy way of configuring your projects. Rather uniquely we're using Clojure TI Tools, Cheshire for adjacent

Charlie - I think that's kind of the case with most projects here, like the teams pick the tools they want and then it's not necessarily very unified across teams.

Jon - It's good to have a fraction of R&D though, isn't it? Just to try different things, keep an eye out.

Joachim - I think one of the things I saw as a big improvement was the advent of Visual studio code together with Kava to bring a more standardised way of doing things. I did struggle a little bit with Space-maker, email and Fireplace and VIM and how you set all of that up for Cider. Even though it's a really great tool it is a lot more involved in the initial set up where I prefer things which work right out of the box. I've used a bit of Cursive on Intelli-J before, but that just felt a bit wrong to kind of use that and I think now probably most people use Visio Studio code for for Python, JavaScript, but Kava now has very good Clojure support. Obviously everyone's able to choose their own editor but I think it's great that this kind of support is available and can provide people a good out of the box experience to get people started.

Charlie - I think the default now is like if you're a new joiner and you don't already use Vim or E Macs, you probably end up using VS code and Kava. And if you do, then you just keep using what you're using. I haven't seen that many people jump onto starting using one of the other ones while learning Clojure.

Richard - One of the new starters that we mentioned earlier who was learning Clojure and is a Lisper hadn't used Emacs before but did take on both Emacs and Clojure at the same time. His mindset helped, but he seems to have taken to it very well. The other new starter is using VS code and so I think mostly VS Code at least 50%.

Joachim - I think my take on Emacs and Vim is that if you give it an honest try and are still struggling after 6 months to find the right key codes then it's probably not for you. I was basically one of those guys. I think some people use it really well but other people do struggle.

Rahul - I think with my background I'm firmly on the VIM camp. On the library side because we deal with large sets of data that are fast flowing, I prefer to use Chard which handles JSON and CSV more efficiently and is how we're able to process 70 megabytes in milliseconds. There's a different thought process in the Clojure libraries used in Infrastructure vs. Application.


We're using Babashka more and it's eating up our Python.

Jon - You mentioned Babashka, can you tell us more about that?

Rahul - I'm one of the parents of this project, contributing and maintaining it for a couple of years now along with Bob Duke. Primarily from my use case, it's in these glue code or automation things that we have a set of scripts that goes around and babysits this bunch of clusters of machines. Our world primarily revolves around the literal raw machines with the rest of the people in the core  built on top of. So there's a bunch of scripts says things such as 'this machine could be recycled better', 'there's a reason that these machines need a bit of help'. These things tend to be in Python or Babashka or Go. More and more we're going towards Babashka or not even any code,  but now they're more and more going towards Babashka or, or not even any code. Some of the more fun use cases are partial recovery for unstructured data and Babashka setups through a large set of discs and figures our what needs to be done and we also have an onboarding script for new people; the script writes an email, sets up with VPN and their AWS account, that's all done in Babashka.

Richard - If I can add a bit to that from my personal opinion, Babaskha can be seen as a better Python for certain scenarios. I've done plenty of Python in the past and it has been my go-to language for getting stuff done quickly. But if you're programming in Clojure anyway, you get the benefits of Clojure, plus you get the speed and immediacy of Python. I like the fact that you can play your dependencies in the same script. Recently I wrote a quick command line tool to sniff??, which just attaches to an SNS topic, create a temporary queue, and just read off that queue. So it's like tailing an SNS topic basically. That's a few lines of Babashka and it's a very nice looking online tool and it's just one script with all the dependencies built in. I think we could probably use it more and maybe even replace Make with it because, it's got tasks, I think there's lots of potential in various places. So, I'd like to see everybody use more of it.

Jon -  What do you think of the general state of Clojure?

Richard - I think it's stability is a great thing, which is sometimes mistaken for stagnation by people who don't understand that it's stability is important. The language itself, as Luke said, is not growing, but I don't think it should, it's perfectly good as it is. But what is growing is the community around it. Things like Babashka in the ecosystem. I think the Clojure world is quite exciting and hopefully my colleagues share that excitement. So, uh, I think. There's plenty of, plenty of liveliness in, in the closure eco ecosystem. Um, yeah, that's, that's my opinion.

Rahul - I think the data science aspect of it, there's been a fair amount of chat in the Clojure code team, from Alex Miller. We are doing something around the data science stuff and so I'm fairly pumped to hopefully see a lot of data science libraries coming out. And London Clojurians have this whole site load which is pumping towards more and more, those directions, looking at the higher quality native integration between JVM etc. I'm pumped about those aspects of Clojure which hopefully means we can do some data science.

Jon - Is there anything else you want to add

Jeremy - When I spoke to Luca last year with Steve as well we discussed the desire to move everything to service. Are you still working towards that direction. Is Amazon, AWS still a key linchpin of that strategy or do you find writing your own wrappers works well? Is Clojure aiding that move to everything as service? Obviously there's a lot of ways you can run things in the cloud, maybe using Lambda, maybe you're thinking of running Babashka or Native Clojure in Lambda, is Clojure forming an integral part of your move or desire to run things as a service?

Luca - I would say yes. Our cloud partner is here to stay. It's not one of those things you're going to change on a monthly basis and it's our love. Clojure is here to stay so these are two, although in completely different parts of the technology world are our two key components on our strategy. I think the one thing that we have in our ethos is not just trying to do everything in a single language. I think if we find the right support in Clojure and the right solution for a problem we're going to for that within the AWS ecosystem.

Jeremy - As an example with AWS, there's lots configuration out there in YAML. Do you have a lot of YAML in your stack or are you doing a lot of that kind of stuff in Clojure as well?

Richard - I think we've got a fair amount of YAML, haven't we Never got around with some YAML, right. Xml, it's, it's major paraform. To be honest, we don't,

Charlie I don't think we really use, except for tying, gluing things, stuff together. Closure for infrastructure is more like for scripting, scripting language in Babashka to tie together different process around Terraform.

Rahul - Yeah, something like Terraform has been like our go-to thing for infrastructures there's like a fair amount of expertise around it as well. Clojure is more the brains needed between these two pieces of infrastructure

Charlie - Specifically to your mention of Amazonica, which is quite a good example of something I think that Clojure may suffer from is, uh, it's, I think we still mainly reach for Amazonica when interacting with services, but it is a concern that it's maintained by one guy who doesn't work on Clojure anymore and it's built in SDK, which is essentially dead and might get dropped by Amazon at some point. This is one of the things where it can sometimes be a bit painful in Clojure where the community has to build something and to serve something that would otherwise be provided by your cloud provider or a big corporation.

Rahul -  the AWS API from Cognitect, I mean, as, as good as it is, like, but then like we have problems. Like we can't do single sign on. With that, and , we can't raise any pool requests there and like it's kind built on its own and there's no Clear indication if they want to support us as well. Because it's like a big thing in our, the way we run our things and we can't do it with the current library??. So like Charlie is like this one person, other maintainer for Amazonica, literally apart from the other . So we kind of hack around these things as well. So there's like a bit of a friction between like the way certain libraries are blocks. I guess especially from the, the  side. Yeah.

Charlie - You, you definitely tend to like closure, find like a library maintained by one guy as opposed to in other ecosystems you'd have a much richer pool of maintainers who are much more willing to Yeah.Make changes or have much more time to make changes. Cause there's more people of course. Not everyone's a force of nature, like Bock Dude

Jon - Okay well I just want to say thank you for your time, it's really appreciated.
