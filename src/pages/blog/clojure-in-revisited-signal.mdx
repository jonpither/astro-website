---
author: 'jon'
title: 'Clojure in Revisited: Signal
description: ''
category: 'clojure-in'
layout: '../../layouts/BlogPostClojureIn.astro'
publishedDate: '2023-06-20'
heroImage: 'gresham-logo-clojurein-new.jpg'
clojureIn:
  {
    season: 'two',
    industry: 'finance',
    quote: '"Our heart is in Clojure."'
  }
---

////
;; TODO REVIEW watch vid, correct tooling and lib names:
////

import { Image } from '@astrojs/image/components'

Signal is an AI company that extracts knowledge from unstructured textual content and processes near to 5 million documents a day from various data sources, providing insights to it's subscribers.

JUXT visited Signal for a Clojure In [five years ago](https://www.juxt.pro/blog/clojure-in-signal/). I wanted to revisit to understand if Clojure has stood the test of time, and how they feel about it now.

I met with VP of engineering Alan Wright, Senior Software Engineers Joachim Draeger and Charlie Briggs, Richard Lewis Jones on the Search Team, Rahul DÃ© (Site Reliability Engineer), and CTO Luca Grulla.

## Languages

**Jon: What languages do you use now?**

**Luca:** Historically, we've built everything using three ecosystems, JVM with Clojure, Node with JavaScript, and Python.

We use JavaScript for the front-end and some APIs, and Python for machine learning and data science.

**Joachim:** Yeah, Clojure is then our go-to language for APIs and data manipulation. It also shines if you need to do anything fast in a multi-threaded way.

**Richard:** We're also using Clojure to build an abstract interface on top of Elastic Search.

**Jon: Have you looked at Clojure for the Data Science part, rather than Python?**

**Charlie:** - We've realized that if you need to do any data science, just start with Python. We haven't tried to shoehorn Clojure into that ecosystem. In the previous Clojure In interview, Miguel talked about the improvements of data science on Clojure and it doesn't seem to have come to fruition in any way that that's usable for us in production.

**Joachim:** You can't really compare the data science ecosystem between Clojure and Python, it's all happening in the Python space.

**Jon: So why not use Python throughout?**

**Charlie:** The most powerful feature I find with Clojure is how easy it is to do multi-threading and parallelism and get good performance out of the box. It's very hard to use Python because of global interpreter lock and similar issues. Whenever we've tried to tackle it, it's always been a bit of a pain.

**Joachim:** It takes a lot more effort with Python to get all the dependencies straight and to get it to work properly in Docker. The JVM is a lot more mature in that sense. It's easier to run Clojure services in production, to scale and to monitor them than it is for for Python.

Clojure is also great for any kind of data manipulation. Our machine learning pipelines and APIs are all using a mix of Python/Clojure.

**Rahul:** We've historically used Python for infrastructure automation. Where we're dealing with a lot of unstructured data and especially query analysis for Elastic, we will use a mix of languages including Clojure. If you compare Golang and Clojure in terms of handling unstructured dynamic data, that's a big plus point for Clojure.

**Jon: Could you expand more on what you do with unstructured dynamic data?**

**Rahul:** The primary use case that we have is to run this massive search cluster and we monitor this cluster at all times. We need to protect it against large queries that could overwhelm or load the cluster. Clojure allows us to walk the tree with it's standard library and preemptively measure the severity of a query and therefore reduce the impact.

## Clojure

**Jon:** It's quite inspiring, you've got those three different languages for each relevant area and you choose which one works best. It's great to hear that Clojure is holding it's own.

**Charlie:** It's nice to see that if you go back to a project that was written five years ago and it's basically more or less still doing the same thing and holds up well. It seems there's definitely less fatigue in terms of progression in the style than we've seen in Python or JavaScript.

**Luca:** This to me is the strength of Clojure. The design of the core library is of such high quality that there's no major changes, not because there's no innovation but because it achieves such a level of instruction. Unlike other languages where the framework is constantly being revisited, you can do a lot with the core library, it stands the testament of time.

**Jon:** How have you found it in terms of hiring and training for Clojure?

**Charlie:** I joined because I wanted to learn Clojure.

**Richard:** I don't consider there a problem picking up Clojure. It's an attractive thing for people who have discovered it.

For example we've had two recent joiners who hadn't used Clojure before. One has Lisp/C# experience and the other had Python. They were both aware of functional language concepts and they were quick to pick it up.

To help with this, for a time we ran a Clojure club, so people who aren't familiar can get support from people with experience.

**Rahul:** The club was born from people who were learning it and they've built a framework and wiki which is available to the team, which shows them how to go about the learning.

**Charlie:** I think it's great we have this now as when I joined it wasn't so in-depth, there were reading suggestions but now it's more comprehensive.

**Jon: It's great, you've got a full range of people: from juniors learning the technology, people joining for the technology, and then people you've pulled across from adjacent technologies like Python and Common Lisp. Have you had any challenges from the team with your decision to adopt Clojure?**

**Richard:** Not really, it's nice to play around with new technologies but our heart is in Clojure.

**Jon: What do you think of the general state of Clojure?**

**Richard:** Stability is a great thing, which is sometimes mistaken for stagnation by people who don't understand that stability is important. The language itself, as Luke said, is not growing, but I don't think it should; it's perfectly good as it is.

The community is growing around it with new ecosystem technologies like Babashka. I think the Clojure world is quite exciting and hopefully my colleagues share that excitement.

## Working with dynamic data

**Jon: It feels you're aligned to dynamic languages. Do you feel the static versus dynamic debate has moved on at all?**

**Richard:** I'm attracted to the elegance of some of the newer languages out there on the frontend such as Elm and Reason. I'm not a fan of TypeScripts because it's a halfway house, it's not inferred, so you just end up with horrible types you've got to deal with. Languages that are properly typed first, they're nice, but it's not necessarily suitable for a lot of what we're doing, so Clojure wins.

**Charlie:** We've had some pain with things not being typed for maintenance, such as APIs. I feel the solution for that is not necessarily adding types to the language but definitely adding more schemas, and structure to the data you consume and produce.

We tried to use Clojure spec to make our boundaries more strict. We found found it hard to work with, and now we use Mali and it just seems more intuitive. We never really got to grips with how to structure our specs and actually to use them in the right context, like development Vs production. You seem to need to do a lot of work to make actually fit for human consumption.

**Richard:** On my team we also use Mali and other tools from Metosin for routing.

## Editor Wars

**Jon: What IDE do you use?**

**Joachim:** Most people use Visio Studio code for for Python and JavaScript, but now we have very good Clojure support with Kava. Obviously everyone's able to choose their own editor but I think it's great that this kind of support is available and can provide people a good out of the box experience to get people started.

**Charlie:** If you're a new joiner and you don't already use Vim or E Macs, then you will probably end up using VS code and Kava. I haven't seen that many people jump over to another IDE whilst learning Clojure.

**Richard:** One of our new starters who was learning Clojure and is a Lisper, hadn't used Emacs before but did take on both Emacs and Clojure at the same time. His mindset helped, but he seems to have taken to it very well.

**Joachim:** My take on Emacs and Vim is that if you give it an honest try and are still struggling after 6 months, then it's probably not for you. I was basically one of those people. I think some people use it really well but other people do struggle.

**Rahul:** I'm firmly in the VIM camp.

## Tooling

**Jon: What tools and libraries do you use?**

**Richard:** In the Search team we're aiming for simplicity at all costs. For lifecycle we're with Mount and configuration we're using CPROP and I think that's a fairly simple and easy way of configuring your projects. Rather uniquely we're using Clojure TI Tools, Cheshire for JSON.

For dealing with large sets of data that are fast flowing, I prefer to use Chard? which handles JSON and CSV more efficiently and is how we're able to process 70 megabytes in milliseconds. used in Infrastructure vs. Application.

**Jon: You mentioned Babashka, can you tell us more?**

**Rahul:** I'm one of the parents of this project, contributing and maintaining it for a couple of years now along with Bork Dude. We use it for monitoring clusters of machines. I.e. our scripts tell us: 'this machine could be recycled better', or 'here's why these machines need a bit of help'.

Other Babashka use cases are partial recovery for unstructured data and even an onboarding script for new people; the script writes an email, sets up with VPN and their AWS account, that's all done in Babashka.

**Jon:** Cool!

**Richard:** Babaskha can be seen as a better Python for certain scenarios. I've done plenty of Python in the past and it has been my go-to language for getting stuff done quickly. But if you're programming in Clojure to begin with, you get the benefits of Clojure, plus you get the same speed and immediacy that Python gives.

I like the fact that you can play your dependencies in the same script. Recently I wrote a quick command line tool to tail SNS topics, which just attaches to an SNS topic, create a temporary queue, and just read off that queue. That's a few lines of Babashka and it's a very nice looking online tool and it's just one script with all the dependencies specified.

**Wrapping up:**

**Jon:** Is there anything else you want to add?

Jeremy - When I spoke to Luca last year with Steve as well we discussed the desire to move everything to serverless. Are you still working towards that direction. Is Amazon, AWS still a key linchpin of that strategy or do you find writing your own wrappers works well? Is Clojure aiding that move to everything as service? Obviously there's a lot of ways you can run things in the cloud, maybe using Lambda, maybe you're thinking of running Babashka or Native Clojure in Lambda, is Clojure forming an integral part of your move or desire to run things as a service?

Luca - I would say yes. Our cloud partner is here to stay. It's not one of those things you're going to change on a monthly basis and it's our love. Clojure is here to stay so these are two, although in completely different parts of the technology world are our two key components on our strategy. I think the one thing that we have in our ethos is not just trying to do everything in a single language. I think if we find the right support in Clojure and the right solution for a problem we're going to for that within the AWS ecosystem.

Jeremy - As an example with AWS, there's lots configuration out there in YAML. Do you have a lot of YAML in your stack or are you doing a lot of that kind of stuff in Clojure as well?

Richard - I think we've got a fair amount of YAML, haven't we Never got around with some YAML, right. Xml, it's, it's major paraform. To be honest, we don't,

Charlie I don't think we really use, except for tying, gluing things, stuff together. Closure for infrastructure is more like for scripting, scripting language in Babashka to tie together different process around Terraform.

Rahul - Yeah, something like Terraform has been like our go-to thing for infrastructures there's like a fair amount of expertise around it as well. Clojure is more the brains needed between these two pieces of infrastructure

Charlie - Specifically to your mention of Amazonica, which is quite a good example of something I think that Clojure may suffer from. We still mainly reach for Amazonica when interacting with services, but it is a concern that it's maintained by one person who doesn't work on Clojure anymore and it's built in SDK, which is essentially dead and might get dropped by Amazon at some point.

With Clojure you definitely tend to see libraries being maintained by one person as opposed to in other ecosystems where you'd have a much richer pool of maintainers. Not everyone's a force of nature, like Borkdude.

**Jon: Okay well I just want to say thank you for your time, it's really appreciated.**
